# Почему так сделали

---

## Laravel

Взяли Laravel потому что всё уже есть: роуты, модели, миграции, Sanctum под API, тесты. Не надо самим всё это пилить — сразу пишем логику. Плюс PHP и Laravel многие знают.

---

## PostgreSQL

Нужна нормальная база, где всё корректно работает когда много людей трогают одни и те же данные. Postgres умеет транзакции и блокировки, так что если двое мастеров одновременно берут одну заявку — всё ок, не сломается. MySQL тоже подойдёт, но в постгресе проще с такими вещами.

---

## Race condition — как не дать двоим взять одну заявку

Бывает так: два мастера жмут «взять» на одну заявку в один момент. Должен выиграть только один.

Как сделали: `SELECT ... FOR UPDATE` (lockForUpdate в Laravel) — блокируем строку в транзакции. Второй запрос ждёт, пока первый освободит блокировку, затем видит уже обновлённый статус и получает 409. Один запрос успевает, второй — нет. Скрипт `race_test.sh` шлёт два curl параллельно, один 200, один 409.

---

## Авторизация — по имени и токены

Сделали максимально просто: логин по имени, без пароля. В базе уже есть юзеры из сидов, вводишь имя — получаешь токен. Для нашего случая хватает.

Токены через Sanctum: в заголовок ставим Bearer, на каждом запросе проверяем. Сессий нет, куков нет. Роли (dispatcher / master) — просто поле в таблице users. Middleware смотрит роль и не пускает куда не надо. Когда понадобится — добавим пароли.

---

## Как всё устроено по слоям

**Бекенд**

- Роуты в api.php — сгруппированы по ролям (auth, dispatcher, master)
- Контроллеры — по сути только дергают сервис и отдают JSON
- RequestService — вся логика заявок: assign, cancel, take, complete. Там же транзакции
- Модели Request и User — работа с базой

**Фронт**

- Vue 3, роутер, отдельные лейауты под диспетчера и мастера
- API через axios
- Обычные компоненты и страницы

**Docker**

- backend и frontend в разных папках, свои зависимости
- В compose: backend, nginx, postgres, frontend
- local_test.sh — поднимает всё и гоняет тесты
- race_test.sh — проверяет гонку

Бек и фронт раздельно, но в одном репо — так удобнее разрабатывать и деплоить.

---

## Audit log — история действий по заявке

Для каждой заявки сохраняем события: created, assigned, canceled, taken, completed. Таблица `request_audit_logs` хранит user_id, from_status, to_status, metadata. API: `GET /api/dispatcher/requests/{id}/audit` и `GET /api/master/requests/{id}/audit`. Мастер видит только свои заявки.
